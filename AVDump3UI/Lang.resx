<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Processing.BufferLength.Description" xml:space="preserve">
    <value>Circular buffer size for hashing</value>
  </data>
  <data name="Processing.BufferLength.Example" xml:space="preserve">
    <value>--BufferLength=&lt;Size in MiB&gt;</value>
  </data>
  <data name="FileDiscovery.Concurrent.Description" xml:space="preserve">
    <value>Sets the maximal number of files which will be processed concurrently.
First param (max) sets a global limit. (path,max) pairs sets limits per path.</value>
  </data>
  <data name="FileDiscovery.Concurrent.Example" xml:space="preserve">
    <value>--Concurrent=&lt;max&gt;[:&lt;path1&gt;,&lt;max1&gt;;&lt;path2&gt;,&lt;max2&gt;...]</value>
  </data>
  <data name="Processing.Consumers.Description" xml:space="preserve">
    <value>Select consumers to use. Use without arguments to list available consumers</value>
  </data>
  <data name="Processing.Consumers.Example" xml:space="preserve">
    <value>--Consumers=&lt;ConsumerName1&gt;[,&lt;ConsumerName2&gt;...]</value>
  </data>
  <data name="Reporting.CRC32Error.Description" xml:space="preserve">
    <value>Searches the filename for the calculated CRC32 hash. If not present or different a line with the caluclated hash and the full path of the file is appended to the specified path
The regex pattern should contain the placeholder ${CRC32} which is replaced by the calculated hash prior matching.
Consumer CRC32 will be force enabled!</value>
  </data>
  <data name="Reporting.CRC32Error.Example" xml:space="preserve">
    <value>--CRC32Error=&lt;Filepath&gt;,&lt;RegexPattern&gt;</value>
  </data>
  <data name="FileDiscovery.DoneLogPath.Description" xml:space="preserve">
    <value>Will set --SkipLogPath and --ProcessedLogPath to the specified filepath</value>
  </data>
  <data name="FileDiscovery.DoneLogPath.Example" xml:space="preserve">
    <value>--DoneLogPath=&lt;Filepath&gt;</value>
  </data>
  <data name="Diagnostics.ErrorDirectory.Description" xml:space="preserve">
    <value>If --SaveErrors is specified the error files will be placed in the specified path</value>
  </data>
  <data name="Diagnostics.ErrorDirectory.Example" xml:space="preserve">
    <value>--ErrorDirectory=&lt;DirectoryPath&gt;</value>
  </data>
  <data name="Reporting.ExtensionDifferencePath.Description" xml:space="preserve">
    <value>Logs the filepath if the detected extension does not match the actual extension</value>
  </data>
  <data name="Reporting.ExtensionDifferencePath.Example" xml:space="preserve">
    <value>--EDPath=extdiff.txt</value>
  </data>
  <data name="Diagnostics.IncludePersonalData.Description" xml:space="preserve">
    <value>Various places may include personal data. Currently this only affects error files, which will then include the full filepath</value>
  </data>
  <data name="Diagnostics.IncludePersonalData.Example" xml:space="preserve">
    <value>--IncludePersonalData</value>
  </data>
  <data name="Diagnostics.NullStreamTest.Description" xml:space="preserve">
    <value>Use Memory as the DataSource for HashSpeed testing. Overrides any FileDiscovery Settings!</value>
  </data>
  <data name="Diagnostics.NullStreamTest.Example" xml:space="preserve">
    <value>--NullStreamTest=&lt;StreamCount&gt;:&lt;StreamLength in MiB&gt;:&lt;ParallelStreamCount&gt;</value>
  </data>
  <data name="Processing.PauseBeforeExit.Description" xml:space="preserve">
    <value>Pause console before exiting</value>
  </data>
  <data name="Processing.PauseBeforeExit.Example" xml:space="preserve">
    <value>--PauseBeforeExit</value>
  </data>
  <data name="Reporting.PrintHashes.Description" xml:space="preserve">
    <value>Print calculated hashes in hexadecimal format to console</value>
  </data>
  <data name="Reporting.PrintHashes.Example" xml:space="preserve">
    <value>--PrintHashes</value>
  </data>
  <data name="Reporting.PrintReports.Description" xml:space="preserve">
    <value>Print generated reports to console</value>
  </data>
  <data name="Reporting.PrintReports.Example" xml:space="preserve">
    <value>--PrintReports</value>
  </data>
  <data name="FileDiscovery.ProcessedLogPath.Description" xml:space="preserve">
    <value>Appends the full filepath to the specified path</value>
  </data>
  <data name="FileDiscovery.ProcessedLogPath.Example" xml:space="preserve">
    <value>--ProcessedLogPath=&lt;FilePath1&gt;[:&lt;FilePath2&gt;...]</value>
  </data>
  <data name="FileDiscovery.Recursive.Description" xml:space="preserve">
    <value>Recursively descent into Subdirectories</value>
  </data>
  <data name="FileDiscovery.Recursive.Example" xml:space="preserve">
    <value>--Recursive</value>
  </data>
  <data name="Reporting.ReportDirectory.Description" xml:space="preserve">
    <value>Reports will be saved to the specified directory</value>
  </data>
  <data name="Reporting.ReportDirectory.Example" xml:space="preserve">
    <value>--ReportDirectory=&lt;Directory&gt;</value>
  </data>
  <data name="Reporting.ReportFileName.Description" xml:space="preserve">
    <value>Reports will be saved/appended to the specified filename
Placeholders mentioned in --FileMove.Pattern can be used as well.
Additional placeholders: ReportName, ReportFileExtension
</value>
  </data>
  <data name="Reporting.ReportFileName.Example" xml:space="preserve">
    <value>--ReportFileName=&lt;FileName&gt;</value>
  </data>
  <data name="Reporting.Reports.Description" xml:space="preserve">
    <value>Select reports to use. Use without arguments to list available reports</value>
  </data>
  <data name="Reporting.Reports.Example" xml:space="preserve">
    <value>--Reports</value>
  </data>
  <data name="Diagnostics.SaveErrors.Description" xml:space="preserve">
    <value>Errors occuring during program execution will be saved to disk</value>
  </data>
  <data name="Diagnostics.SaveErrors.Example" xml:space="preserve">
    <value>--SaveErrors</value>
  </data>
  <data name="Diagnostics.SkipEnvironmentElement.Description" xml:space="preserve">
    <value>Skip the environment element in error files</value>
  </data>
  <data name="Diagnostics.SkipEnvironmentElement.Example" xml:space="preserve">
    <value>--SkipEnvironmentElement</value>
  </data>
  <data name="FileDiscovery.SkipLogPath.Description" xml:space="preserve">
    <value>Filepaths contained in the specified file will not be processed</value>
  </data>
  <data name="FileDiscovery.SkipLogPath.Example" xml:space="preserve">
    <value>--SkipLogPath=&lt;FilePath1&gt;[:&lt;FilePath2&gt;...]</value>
  </data>
  <data name="FileDiscovery.WithExtensions.Description" xml:space="preserve">
    <value>Only/Don't Process files with selected Extensions</value>
  </data>
  <data name="FileDiscovery.WithExtensions.Example" xml:space="preserve">
    <value>--WithExtensions=[-]&lt;Extension1&gt;[,&lt;Extension2&gt;...]</value>
  </data>
  <data name="FileMove.LogPath.Description" xml:space="preserve">
    <value>A line is written for each file that has been moved/renamed. (OldPath =&gt; NewPath)</value>
  </data>
  <data name="FileMove.LogPath.Example" xml:space="preserve">
    <value>--FileMove.LogPath=&lt;FilePath&gt;</value>
  </data>
  <data name="FileMove.Mode.Description" xml:space="preserve">
    <value>Determines how the Pattern Argument is going to be interpreted:
Inline: Script is directly entered as the argument
File: A path pointing to the script file
Placeholder: See example for --Pattern
CSharpScript: Script in C#
DotNetAssembly: Net Core assembly to be loaded</value>
  </data>
  <data name="FileMove.Mode.Example" xml:space="preserve">
    <value>--FileMove.Mode=&lt;None|PlaceholderInline|PlaceholderFile|CSharpScriptInline|CSharpScriptFile|DotNetAssembly&gt;</value>
  </data>
  <data name="FileMove.DisableFileMove.Description" xml:space="preserve">
    <value>Don't move the file even if the Pattern says so</value>
  </data>
  <data name="FileMove.DisableFileMove.Example" xml:space="preserve">
    <value>--FileMove.DisableFileMove</value>
  </data>
  <data name="FileMove.DisableFileRename.Description" xml:space="preserve">
    <value>Don't rename the file even if the Pattern says so</value>
  </data>
  <data name="FileMove.DisableFileRename.Example" xml:space="preserve">
    <value>--FileMove.DisableFileRename</value>
  </data>
  <data name="FileMove.Pattern.Description" xml:space="preserve">
    <value>Available Placeholders in the form of ${Name}:
FileSize, FullName, FileName, FileExtension, FileNameWithoutExtension, DirectoryName, SuggestedExtension,
Hash-&lt;Name&gt;-&lt;2|4|8|10|16|32|32Hex|32Z|36|62|64&gt;-&lt;OC|UC|LC&gt;</value>
  </data>
  <data name="FileMove.Pattern.Example" xml:space="preserve">
    <value>--FileMove.Pattern=${DirectoryName}\${FileNameWithoutExtension}${SuggestedExtension}</value>
  </data>
  <data name="FileMove.Replacements.Description" xml:space="preserve">
    <value>Replace substrings in the returned filepath</value>
  </data>
  <data name="FileMove.Replacements.Example" xml:space="preserve">
    <value>--FileMove.Replacements=&lt;Match1&gt;=&lt;Replacement1&gt;[;&lt;Match2&gt;=&lt;Replacement2&gt;...]</value>
  </data>
  <data name="FileMove.Test.Description" xml:space="preserve">
    <value>Test FileMove Settings</value>
  </data>
  <data name="FileMove.Test.Example" xml:space="preserve">
    <value>--FileMove.Test</value>
  </data>
  <data name="Processing.ProducerMaxReadLength.Description" xml:space="preserve">
    <value>How much data in MiB the reader is allowed to read each time at most</value>
  </data>
  <data name="Processing.ProducerMaxReadLength.Example" xml:space="preserve">
    <value>--ProducerMaxReadLength</value>
  </data>
  <data name="Processing.ProducerMinReadLength.Description" xml:space="preserve">
    <value>How much data in MiB the reader has to read each time at minimum</value>
  </data>
  <data name="Processing.ProducerMinReadLength.Example" xml:space="preserve">
    <value>--ProducerMinReadLength</value>
  </data>
  <data name="Processing.PrintAvailableSIMDs.Description" xml:space="preserve">
    <value>Print available CPU SIMDs</value>
  </data>
  <data name="Processing.PrintAvailableSIMDs.Example" xml:space="preserve">
    <value>--PrintAvailableSIMDs</value>
  </data>
  <data name="Diagnostics.PrintDiscoveredFiles.Description" xml:space="preserve">
    <value>Print each discovered file path instead of printing the count</value>
  </data>
  <data name="Diagnostics.PrintDiscoveredFiles.Example" xml:space="preserve">
    <value>--PrintDiscoveredFiles</value>
  </data>
  <data name="Diagnostics.Version.Description" xml:space="preserve">
    <value>Print the program version to console</value>
  </data>
  <data name="Diagnostics.Version.Example" xml:space="preserve">
    <value>--Version</value>
  </data>
</root>