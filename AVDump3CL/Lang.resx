<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BufferLengthDescription" xml:space="preserve">
    <value>Circular buffer size for hashing</value>
  </data>
  <data name="BufferLengthExample" xml:space="preserve">
    <value>--BufferLength=&lt;Size in MiB&gt;</value>
  </data>
  <data name="ConcurrentDescription" xml:space="preserve">
    <value>Sets the maximal number of files which will be processed concurrently.
First param (max) sets a global limit. (path,max) pairs sets limits per path.</value>
  </data>
  <data name="ConcurrentExample" xml:space="preserve">
    <value>--Concurrent=&lt;max&gt;[:&lt;path1&gt;,&lt;max1&gt;;&lt;path2&gt;,&lt;max2&gt;;...]</value>
  </data>
  <data name="ConsumersDescription" xml:space="preserve">
    <value>Select consumers to use. Use without arguments to list available consumers</value>
  </data>
  <data name="ConsumersExample" xml:space="preserve">
    <value>--Consumers=&lt;ConsumerName1&gt;[,&lt;ConsumerName2&gt;,...]</value>
  </data>
  <data name="CRC32ErrorDescription" xml:space="preserve">
    <value>Searches the filename for the calculated CRC32 hash. If not present or different a line with the caluclated hash and the full path of the file is appended to the specified path
The regex pattern should contain the placeholder "&lt;CRC32&gt;" which is replaced by the calculated hash prior matching</value>
  </data>
  <data name="CRC32ErrorExample" xml:space="preserve">
    <value>--CRC32Error=&lt;Filepath&gt;:&lt;RegexPattern&gt;</value>
  </data>
  <data name="DoneLogPathDescription" xml:space="preserve">
    <value>Will set --SkipLogPath and --ProcessedLogPath to the specified filepath</value>
  </data>
  <data name="DoneLogPathExample" xml:space="preserve">
    <value>--DoneLogPath=&lt;Filepath&gt;</value>
  </data>
  <data name="ErrorDirectoryDescription" xml:space="preserve">
    <value>--ErrorDirectory=&lt;DirectoryPath&gt;</value>
  </data>
  <data name="ErrorDirectoryExample" xml:space="preserve">
    <value>If --SaveErrors is specified the error files will be placed in the specified path</value>
  </data>
  <data name="ExtensionDifferencePathDescription" xml:space="preserve">
    <value>Logs the filepath if the detected extension does not match the actual extension</value>
  </data>
  <data name="ExtensionDifferencePathExample" xml:space="preserve">
    <value>--EDPath=extdiff.txt</value>
  </data>
  <data name="ForwardConsoleCursorOnlyDescription" xml:space="preserve">
    <value>The cursor position of the console will not be explicitly set. This option will disable most progress output</value>
  </data>
  <data name="ForwardConsoleCursorOnlyExample" xml:space="preserve">
    <value>--ForwardConsoleCursorOnly</value>
  </data>
  <data name="HideBuffersDescription" xml:space="preserve">
    <value>Hides buffer bars</value>
  </data>
  <data name="HideBuffersExample" xml:space="preserve">
    <value>--HideBuffers</value>
  </data>
  <data name="HideFileProgressDescription" xml:space="preserve">
    <value>Hides file progress</value>
  </data>
  <data name="HideFileProgressExample" xml:space="preserve">
    <value>--HideFileProgress</value>
  </data>
  <data name="HideTotalProgressDescription" xml:space="preserve">
    <value>Hides total progress</value>
  </data>
  <data name="HideTotalProgressExample" xml:space="preserve">
    <value>--HideTotalProgress</value>
  </data>
  <data name="IncludePersonalDataDescription" xml:space="preserve">
    <value>Various places may include personal data. Currently this only affects error files, which will then include the full filepath</value>
  </data>
  <data name="IncludePersonalDataExample" xml:space="preserve">
    <value>--IncludePersonalData</value>
  </data>
  <data name="NullStreamTestDescription" xml:space="preserve">
    <value>Use Memory as the DataSource for HashSpeed testing. Overrides any FileDiscovery Settings!</value>
  </data>
  <data name="NullStreamTestExample" xml:space="preserve">
    <value>--NullStreamTest=&lt;StreamCount&gt;:&lt;StreamLength in MiB&gt;:&lt;ParallelStreamCount&gt;</value>
  </data>
  <data name="PauseBeforeExitDescription" xml:space="preserve">
    <value>Pause console before exiting</value>
  </data>
  <data name="PauseBeforeExitExample" xml:space="preserve">
    <value>--PauseBeforeExit</value>
  </data>
  <data name="PrintHashesDescription" xml:space="preserve">
    <value>Print calculated hashes in hexadecimal format to console</value>
  </data>
  <data name="PrintHashesExample" xml:space="preserve">
    <value>--PrintHashes</value>
  </data>
  <data name="PrintReportsDescription" xml:space="preserve">
    <value>Print generated reports to console</value>
  </data>
  <data name="PrintReportsExample" xml:space="preserve">
    <value>--PrintReports</value>
  </data>
  <data name="ProcessedLogPathDescription" xml:space="preserve">
    <value>Appends the full filepath to the specified path</value>
  </data>
  <data name="ProcessedLogPathExample" xml:space="preserve">
    <value>--ProcessedLogPath=&lt;Filepath&gt;</value>
  </data>
  <data name="RecursiveDescription" xml:space="preserve">
    <value>Recursively descent into Subdirectories</value>
  </data>
  <data name="RecursiveExample" xml:space="preserve">
    <value>--Recursive</value>
  </data>
  <data name="ReportDirectoryDescription" xml:space="preserve">
    <value>Reports will be saved to the specified directory</value>
  </data>
  <data name="ReportDirectoryExample" xml:space="preserve">
    <value>--ReportDirectory=&lt;Directory&gt;</value>
  </data>
  <data name="ReportFileNameDescription" xml:space="preserve">
    <value>Reports will be saved/appended to the specified filename
The following placeholders can be used: &lt;FileName&gt;, &lt;FileNameWithoutExtension&gt;, &lt;FileExtension&gt;, &lt;ReportName&gt;, ReportFileExtension</value>
  </data>
  <data name="ReportFileNameExample" xml:space="preserve">
    <value>--ReportFileName=&lt;FileName&gt;</value>
  </data>
  <data name="ReportsDescription" xml:space="preserve">
    <value>Select reports to use. Use without arguments to list available reports</value>
  </data>
  <data name="ReportsExample" xml:space="preserve">
    <value>--Reports</value>
  </data>
  <data name="SaveErrorsDescription" xml:space="preserve">
    <value>Errors occuring during program execution will be saved to disk</value>
  </data>
  <data name="SaveErrorsExample" xml:space="preserve">
    <value>--SaveErrors</value>
  </data>
  <data name="ShowDisplayJitterDescription" xml:space="preserve">
    <value>Displays the time taken to calculate progression stats and drawing to console</value>
  </data>
  <data name="ShowDisplayJitterExample" xml:space="preserve">
    <value>--ShowDisplayJitter</value>
  </data>
  <data name="SkipEnvironmentElementDescription" xml:space="preserve">
    <value>Skip the environment element in error files</value>
  </data>
  <data name="SkipEnvironmentElementExample" xml:space="preserve">
    <value>--SkipEnvironmentElement</value>
  </data>
  <data name="SkipLogPathDescription" xml:space="preserve">
    <value>Filepaths contained in the specified file will not be processed</value>
  </data>
  <data name="SkipLogPathExample" xml:space="preserve">
    <value>--SkipLogPath=&lt;FilePath&gt;</value>
  </data>
  <data name="WithExtensionsDescription" xml:space="preserve">
    <value>Only/Don't Process files with selected Extensions</value>
  </data>
  <data name="WithExtensionsExample" xml:space="preserve">
    <value>--WithExtensions=[-]&lt;Extension1&gt;[,&lt;Extension2&gt;,...]</value>
  </data>
</root>